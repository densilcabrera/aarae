function out = STI_direct(in, refsignal, AuditoryMasking, doplot, dorefsig)
% This function analyses a previously recorded STI signal that was
% generated by AARAE's STIdirect_signal generator, and derives
% the value of STI, as described by IEC60268-16 (2011).
%
% Before running this function, play and record the STI test signal
% through the acoustic or audio system that you wish to test.
% Note that both the loudspeaker (if used) and microphone (if used) will
% need to be calibrated to make a correct measurement. The loudspeaker may
% also need to be equalized to produce the correct STI spectrum levels.
% Analyse the recorded signal using this function.
%
% Note that AARAE's STIdirect_signal generator allows for the generation of
% at least four types of STI direct measurement test signal. This analyser
% automatically detects which of the signals has been used for the
% measurement and analyses it accordingly.
%
% This function gives the option of using a reference signal - which could
% either be the original STI signal (to correct for minor statistical
% errors in the calculated modulation depth ratio), or the STI signal
% re-recorded in low-noise low-reverberant energy conditions (e.g., at the
% mouth reference point of a head and torso simulator) to also correct for
% transducer effects. The analysis will fail if the reference signal does
% not match the main input audio.
%
% The analysis allows for +/- 5 s of time-shift in the recording with
% respect to the original time structure of the test signal. If the
% recording is delayed or truncated by more than 5 s, then the analysis
% will fail.
%
% This version uses AARAE's linear (actually zero) phase octave band filters.
% Steep filter skirts return the best results, so currently 144 dB/oct
% skirts are used (achieved by setting filterorder to 24).
%
% The input argument AuditoryMasking has the following meaning:
% 0: do not apply auditory masking and threshold
% 1 or 2011: apply edition 4 auditory masking and threshold
% 2 or 2003: apply edition 3 auditory masking and threshold
%
% Code by Densil Cabrera
% version 1.01 (30 March 2015)


% INPUTS AND SETTINGS
if isstruct(in)
    in = choose_from_higher_dimensions(in,2,1);
    audio = in.audio;
    fs = in.fs;
    if isfield(in,'cal')
        cal = in.cal;
        calgain = 10^(cal/20);
    else
        cal = 0;
        calgain = 1;
    end
    
    if isfield(in,'properties')
        if isfield(in.properties,'Fm') ...
                && isfield(in.properties,'startindex') ...
                && isfield(in.properties,'gap')
            Fm_all = in.properties.Fm;
            startindex = in.properties.startindex;
            gap = in.properties.gap;
        else
            warndlg('One or more of the following required fields were not found: properties.Fm, properties.startindex and/or properties.gap.')
            out = [];
            return
        end
    else
        warndlg('properties field required but not found in input')
        out = [];
        return
    end
else
    % CURRENTLY THIS FUNCTION ONLY RUNS WITH AN AARAE STRUCTURE AS INPUT 1
    %     audio = in;
    %     if nargin < 3
    %         cal = inputdlg({'Calibration offset [dB]'},...
    %                            'Cal',1,{'0'});
    %         cal = str2num(char(cal));
    %     end
    %     calgain = 10^(cal/20);
    %     if nargin < 2
    %         fs = inputdlg({'Sampling frequency [samples/s]'},...
    %                            'Fs',1,{'48000'});
    %         fs = str2num(char(fs));
    %     end
    warndlg('AARAE audio structure required as input to STI_direct function')
    out = [];
    return
end

if nargin < 7, dorefsig = 0; end
if nargin < 6, doplot = 1; end
if nargin < 5, AuditoryMasking = 2011; end
if nargin < 4,
    refsignal = [];
    % dialog box to get auditory masking, noise correction  and
    % auralization settings
    prompt = {'Auditory Masking: 0 for none, 1 for 2011 (edition 4), 2 for 2003 (edition 3)', ...
        'Calibration offset (dB):', ...
        'Plotting (0 | 1):',...
        'Additional reference signal (0 | 1)'};
    dlg_title = 'Settings';
    num_lines = 1;
    def = {'1',num2str(round(10*20*log10(calgain))/10),'1','0'};
    answer = inputdlg(prompt,dlg_title,num_lines,def);
    
    if isempty(answer)
        out = [];
        return
    else
        AuditoryMasking = str2num(answer{1,1});
        calgain = 10.^(str2num(answer{2,1})/20);
        doplot = str2num(answer{3,1});
        dorefsig = str2num(answer{4,1});
    end
end

if ~isempty(audio) && ~isempty(fs) && ~isempty(cal) && ~isempty(AuditoryMasking) && ~isempty(doplot) && ~isempty(dorefsig)
    
    audio = mean(audio,3); % mixdown 3rd dimension if it exists
    chans = size(audio,2);
    audio = audio .* calgain; % apply calibration
    if isfield(in,'chanID')
        chanID = in.chanID;
    else
        chanID = cellstr([repmat('Chan',size(audio,2),1) num2str((1:size(audio,2))')]);
    end
    
    % Define the octave band filter parameters
    %bandnumber=21:3:39; % filter band numbers
    %fc=10.^(bandnumber./10); % filter centre frequencies in Hz
    fc = [125, 250, 500, 1000, 2000, 4000, 8000]; % nominal centre freq
    
    
    % -------------------------------------------------------------------------
    % MTF CALCULATIONS
    % -------------------------------------------------------------------------
    
    if dorefsig && isempty(refsignal)
        % Use a menu & dialog box to select a wav file or audio within AARAE
        if isstruct(in)
            selection = choose_audio; % call AARAE's choose_audio function
        end
        if ~isempty(selection) && isstruct(in)
            refsignal = selection.audio; % additional audio data
            fs2 = selection.fs; % sampling rate
            
            if ~(fs2 == fs)
                % match sampling rates if desired
                refsignal = resample(refsignal,fs,fs2);
            end
            [~, chans2, bands2] = size(refsignal); % new wave dimensions
            if bands2 > 1, refsignal = sum(refsignal,3); end % if multiband, mixdown
            if chans2>1, refsignal = refsignal(:,1); end % only 1 channel allowed for ref
            
            % CALCULATE MTF OF REFERENCE SIGNAL
            MTFref = STI_direct_MTF(refsignal,fs,fc,Fm_all,startindex,gap);
        elseif ~isstruct(in)
            MTFref = STI_direct_MTF(refsignal,fs,fc,Fm_all,startindex,gap);
        else
            dorefsig = 0;
        end
    elseif ~isempty(refsignal)
        MTFref = STI_direct_MTF(refsignal,fs,fc,Fm_all,startindex,gap);
    end
    
    % CALCULATE MTF
    [MTF, I, Level] = STI_direct_MTF(audio,fs,fc,Fm_all,startindex,gap);
    
    % adjust MTF by reference signal MTF
    if dorefsig
        MTF = MTF ./ MTFref;
    end
    
    % -------------------------------------------------------------------------
    % APPLY AUDITORY MASKING AND THRESHOLD
    % -------------------------------------------------------------------------
    
    if AuditoryMasking>0
        % AUDITORY MASKING
        % preallocate
        amf=zeros(1,chans,7);     % Auditory Masking Factor
        amfdB=zeros(1,chans,7); % Auditory Masking Factor in dB
        Iam=zeros(1,chans,7);   % Masking Intensity
        
        
        if (AuditoryMasking == 2) || (AuditoryMasking == 2003)
            % auditory masking from 2003 version of the standard
            for ch = 1:chans
                for k=2:7
                    if round(Level(1,ch,k-1))>=46 && round(Level(1,ch,k-1)) <=55
                        amf(k)=0.0001;
                    elseif round(Level(1,ch,k-1))>=56 && round(Level(1,ch,k-1)) <=65;
                        amf(k)=0.000316;
                    elseif round(Level(1,ch,k-1)) >=66 && round(Level(1,ch,k-1)) <=75;
                        amf(k)=0.003162;
                    elseif round(Level(1,ch,k-1)) >=76 && round(Level(1,ch,k-1)) <=85;
                        amf(k)=0.01;
                    elseif round(Level(1,ch,k-1)) >=86 && round(Level(1,ch,k-1)) <=95;
                        amf(k)=0.031622;
                    elseif round(Level(1,ch,k-1)) >95;
                        amf(k)=0.1;
                    end
                    Iam(1,ch,k)=I(1,ch,k-1)*amf(1,ch,k);
                end
            end
        else
            % auditory masking from 2011 version of the standard
            for ch = 1:chans
                for k=2:7
                    if Level(1,ch,k-1)< 63
                        amfdB(1,ch,k)=0.5*Level(1,ch,k-1)-65;
                    elseif Level(1,ch,k-1) < 67;
                        amfdB(1,ch,k)=1.8*Level(1,ch,k-1)-146.9;
                    elseif Level(1,ch,k-1) < 100;
                        amfdB(1,ch,k)=0.5*Level(1,ch,k-1)-59.8;
                    else
                        amfdB(1,ch,k)=-10;
                    end
                    amf(1,ch,k)=10^(amfdB(1,ch,k)/10);
                    Iam(1,ch,k)=I(1,ch,k-1)*amf(1,ch,k);
                end
            end
        end
        % Absolute Speech Reception Threshold
        ART=[46 27 12 6.5 7.5 8 12];
        
        % Intensity of threshold
        Irt=10.^(ART./10);
        
        for k = 1:7
            MTF(1,:,k,:) = MTF(1,:,k,:) .* (repmat(I(1,:,k),[1,1,1,14])) ...
                ./ (repmat(I(1,:,k),[1,1,1,14]) ...
                + repmat(Iam(1,:,k),[1,1,1,14]) ...
                + Irt(k));
        end
    end
    
    
    % -------------------------------------------------------------------------
    % FINAL STAGES OF STI CALCULATION
    % -------------------------------------------------------------------------
    
    % limiting the MTF values to 1 at the maximum.
    MTF(MTF>1) = 1;
    MTF = permute(MTF,[2,4,3,1]);
    
    [M_STI,F_STI,STIPA] = deal(zeros(1,chans));
    MTI = zeros(chans,7);
    
    out.tables = [];
    for ch = 1:chans
        %***************************************************************
        % Calculate STI values, having applied the noise correction and masking
        % settings.
        [M_STI(ch), F_STI(ch), STIPA(ch), MTI(ch,:)] = CalculateSTI(squeeze(MTF(ch,:,:)));
        
        %***************************************************************
        % Plotting
        
        if doplot
            % constants used for plotting
            
            % screen position & size for figures
            bdwidth = 5;
            topbdwidth = 30;
            set(0,'Units','pixels')
            scnsize = get(0,'ScreenSize');
            pos1  = [bdwidth,...
                1/2*scnsize(4) + bdwidth,...
                scnsize(3)/2 - 2*bdwidth,...
                scnsize(4)/1.2 - (topbdwidth + bdwidth)];
            pos_step = 5;
            
            % rainbow colours
            colors = [255, 0, 0; ... % red
                255, 128, 0; ... % orange
                204, 204, 0; ... % dark yellow
                0, 204, 0; ... % mid green
                0, 204, 204; ... % dark cyan
                0, 0, 255; ... % blue
                127, 0, 255]; % violet
            colors = colors / 255; % rescale to 0-1 range
            
            pos = pos1;
            pos(1) = pos(1) + (ch-1)*pos_step;
            % Create figure
            figure('name',['STI_direct Channel ', num2str(ch)],'position', pos);
            
            % plot of mtfs
            subplot(3,1,1)
            hold on
            
            % x axis
            set(gca,'XTickLabel',{'0.63', '0.8', '1', '1.25', '1.6', '2',...
                '2.5', '3.15','4','5','6.3','8','10','12.5'}, ...
                'XTick',1:14)
            xlim([1 14]);
            
            % plot the mtf for each octave band (DisplayName can be used if a
            % legend is added). Use rainbow colours as defined above.
            plot(MTF(ch,:,1),'Color',colors(1,:),'DisplayName','125 Hz');
            plot(MTF(ch,:,2),'Color',colors(2,:),'DisplayName','250 Hz');
            plot(MTF(ch,:,3),'Color',colors(3,:),'DisplayName','500 Hz');
            plot(MTF(ch,:,4),'Color',colors(4,:),'DisplayName','1 kHz');
            plot(MTF(ch,:,5),'Color',colors(5,:),'DisplayName','2 kHz');
            plot(MTF(ch,:,6),'Color',colors(6,:),'DisplayName','4 kHz');
            plot(MTF(ch,:,7),'Color',colors(7,:),'DisplayName','8 kHz');
            
            % Uncomment the following line to add a legend
            % legend('show');
            
            % y-axis limits
            ylim([0 1]);
            
            % Create xlabel
            xlabel('Modulation Frequency (Hz)');
            
            % Create ylabel
            ylabel('Modulation Transfer Ratio');
            
            % Create title
            if chans == 1
                title(['Male STI ', num2str(round(M_STI(ch)*100)/100), ...
                    '; Female STI ', num2str(round(F_STI(ch)*100)/100), ...
                    '  (AM=', num2str(AuditoryMasking), ')'])
            else
                title(['Channel ', num2str(ch), ...
                    ': Male STI ', num2str(round(M_STI(ch)*100)/100), ...
                    '; Female STI ', num2str(round(F_STI(ch)*100)/100), ...
                    '  (AM=', num2str(AuditoryMasking), ')'])
            end
            hold off
            
            subplot(3,1,2)
            % Bar plot of modulation transfer indices
            
            % Plot the values
            bh=bar(MTI(ch,:));
            
            % The following code enables each bar to be coloured individually,
            % using the same colours as the mtf subplot (hence the bar plot
            % acts as a legend for the mtf plot).
            chil=get(bh,'children');
            cd=repmat(1:7,5,1);
            cd=[cd(:);nan];
            colormap(colors);
            set(chil,'facevertexcdata',cd);
            
            % x-axis
            set(gca,'XTickLabel',{'125', '250', '500', '1k', '2k', '4k', '8k'})
            xlabel('Octave Band Centre Frequency (Hz)')
            
            % y-axis
            ylabel('Modulation Transfer Index')
            ylim([0 1])
            
            % show the value of each bar
            for k = 1:7
                if MTI(ch,k) < 0.8
                    % black number above the bar
                    text(k-0.25,MTI(ch,k)+0.05, ...
                        num2str(round(MTI(ch,k)*1000)/1000),'Color','k')
                else
                    % or white number below the top of the bar
                    % (for high MTI values)
                    text(k-0.25,MTI(ch,k)-0.05, ...
                        num2str(round(MTI(ch,k)*1000)/1000),'Color',[1 1 1])
                end
            end
            
            subplot(3,1,3)
            % Plot of octave band signal and noise levels
            hold on
            
            % x-axis
            set(gca,'XTickLabel',{'125', '250', '500', '1k', '2k', '4k', '8k'})
            xlabel('Octave Band Centre Frequency (Hz)')
            
            % y-axis
            ymax = 10*ceil(max(max(Level))/10);
            ylim([0 ymax])
            ylabel('SPL (dB)')
            
            % Sound pressure level of the speech signal
            plot(Level(ch,:),'b','Marker','o','DisplayName','Signal (with noise)')
            Levels(:,1,ch) = Level(ch,:);
            %         % Sound pressure level of physical background noise
            %         plot(Lnoise(ch,:),'Color', [0.6 0.2 0], ...
            %             'Marker','o','DisplayName','Physical Noise')
            %         Levels(:,2,ch) = Lnoise(ch,:);
            if AuditoryMasking > 0
                
                % Sound pressure level of masking from the band below
                plot(10*log10(squeeze(Iam(1,ch,:))),'Color',[0 0.5 0], ...
                    'Marker','x','DisplayName','Masking')
                Levels(:,2,ch) = 10*log10(squeeze(Iam(1,ch,:)));
                % Sound pressure level of the auditory reception threshold
                plot(10*log10(Irt),'k','LineStyle',':', ...
                    'DisplayName','Threshold')
                Levels(:,3,ch) = 10*log10(Irt);
                % Sum of all sources of noise
                %             Inoise_sum = In + Irt + Iam;
                %             plot(10*log10(Inoise_sum), 'r', ...
                %                 'LineWidth',1,'LineStyle','--', ...
                %                 'Marker','+', 'DisplayName','Total Noise')
                %             Levels(:,5,ch) = 10*log10(Inoise_sum);
            end
            legend('show','Location','EastOutside');
            hold off
            
            if isstruct(in)
                f = figure('Name',['STI_IR Channel ',num2str(ch),': STI, MTI & MTF'], ...
                    'Position',[200 200 630 540]);
                %[left bottom width height]
                dat1 = squeeze(MTF(ch,:,:));
                cnames1 = {'125', '250', '500', '1k', '2k', '4k', '8k'};
                rnames1 = {'0.63', '0.8', '1', '1.25', '1.6', '2',...
                    '2.5', '3.15','4','5','6.3','8','10','12.5'};
                t1 =uitable('Data',dat1,'ColumnName',cnames1,'RowName',rnames1);
                %set(t,'ColumnWidth',{60});
                
                dat2 = [MTI(ch,:);Level(ch,:)];
                cnames2 = {'125', '250', '500', '1k', '2k', '4k', '8k'};
                rnames2 = {'MTI', 'Signal SPL (dB)'};
                t2 =uitable('Data',dat2,'ColumnName',cnames2,'RowName',rnames2);
                %set(t,'ColumnWidth',{60});
                
                
                dat3 = [M_STI(ch);F_STI(ch);STIPA(ch)];
                cnames3 = {'value'};
                rnames3 = {'STI male','STI female','STIPA'};
                t3 =uitable('Data',dat3,'ColumnName',cnames3,'RowName',rnames3);
                %set(t,'ColumnWidth',{100});
                
                [~,tables] = disptables(f,[t3 t2 t1],{['Chan ' num2str(ch) ' - STI'],['Chan ' num2str(ch) ' - MTI'],['Chan ' num2str(ch) ' - MTF']});
                out.tables = [out.tables tables];
            end
        end % if doplot
        
        
    end
    out.funcallback.name = 'STI_direct.m';
    out.funcallback.inarg = {refsignal, AuditoryMasking, doplot, dorefsig};
    
    mf = [0.63,0.8,1,1.25,1.6,2,2.5,3.15,4,5,6.3,8,10,12.5];
    doresultleaf(permute(MTF,[2,3,1]),'Modulation transfer ratio',{'Modulation_frequency'},...
        'Modulation_frequency', num2cell(mf),                                'Hz',          true,...
        'Frequency',            num2cell([125,250,500,1000,2000,4000,8000]), 'Hz',          false,...
        'Channel',              chanID,                                      'categorical', [],...
        'name','Modulation_TF_STI');
    
    if AuditoryMasking > 0
        doresultleaf(Levels,'SPL [dB]',{'Frequency'},...
            'Frequency', num2cell([125,250,500,1000,2000,4000,8000]),                   'Hz',          true,...
            'Level',     {'Signal with noise','Masking','Threshold'}, 'categorical', [],...
            'Channel',   chanID,                                                        'categorical', [],...
            'name','Band_SPL_STI');
    else
        doresultleaf(Levels,'SPL [dB]',{'Frequency'},...
            'Frequency', num2cell([125,250,500,1000,2000,4000,8000]), 'Hz',          true,...
            'Level',     {'Signal with noise'},                 'categorical', [],...
            'Channel',   chanID,                                      'categorical', [],...
            'name','Band_SPL_STI');
    end
    
    
else
    out = [];
end
end %eof




% -------------------------------------------------------------------------
% -------------------------------------------------------------------------
% FUNCTION TO CALCULATE MTF
% -------------------------------------------------------------------------
% -------------------------------------------------------------------------
function [MTF, I, Level] = STI_direct_MTF(audio,fs,fc,Fm_all,startindex,gap)
% This is a separate function so that it can be used for the reference
% signal (if desired) and the received signal.

if length(startindex) == 98
    % re-shape the data so that it is in the same form as the simutaneous
    % octave band version post filtered.
    
    % note that the term 'Intensity' is used prematurely to avoid
    % unnecessary memory use
    Intensity = zeros((startindex(2)-1)*14,size(audio,2),7);
    filterorder = 24; % very steep filter skirts improve the performance
    
    for k = 1:7
        for j = 1:14
            Intensity(startindex(j):startindex(j+1)-1,:,k) = ...
                audio(startindex((j-1)*7+k):startindex((j-1)*7+k)+startindex(2)-2,:);
        end
        % Even though the data are already in octave bands, we will filter to
        % remove out-of-band noise. We do this within the for-loop because the
        % bands are already in dimension 3. Squaring converts values to
        % intensity.
        Intensity(:,:,k) = octbandfilter_viaFFT(Intensity(:,:,k),fs,fc(k),filterorder) .^2;
    end
    clear audio 
    
    % overwrite Fm_all and startindex to reflect the re-arranged data
    Fm_all = [0.63,0.8,1,1.25,1.6,2,2.5,3.15,4,5,6.3,8,10,12.5];
    startindex = startindex(1:14);
    
else
    % Use AARAE's linear phase octave band filters
    filterorder = 24; % very steep filter skirts improve the performance
    Intensity = octbandfilter_viaFFT(audio,fs,fc,filterorder) .^2;
end
[len, chans, ~]= size(Intensity);

%lowpass filter
[bl, al] = butter(1,100/(0.5*fs),'low');
Intensity = filtfilt(bl, al, Intensity);

% ideal envelope (with no modulation) - either 7 or 14 sections of ones
% with corresponding gap (of zeros) between them
refenvelope = repmat([ones(startindex(2)-gap,1);zeros(gap,1)],...
    [length(startindex),1]);


% crosscorrelate with 1 kHz band to find lag
[C,LAGS] = xcorr(Intensity(:,1,4),refenvelope,fs*5); % allow +/- 5 s time shift
lagshift = LAGS(C == max(C));
startindex = startindex + lagshift;
if startindex(1) < 1, startindex(1) = 1; end
if length(startindex) ==7
    endindex(1:6) = startindex(2:7)-gap;
    endindex(7) = startindex(7) + startindex(3)-startindex(2)-gap;
    if endindex(7) > len, endindex(7) = len; end
    
    % mean intensity, excluding gaps
    I = mean([Intensity(startindex(1):endindex(1),:,:);...
        Intensity(startindex(2):endindex(2),:,:);...
        Intensity(startindex(3):endindex(3),:,:);...
        Intensity(startindex(4):endindex(4),:,:);...
        Intensity(startindex(5):endindex(5),:,:);...
        Intensity(startindex(6):endindex(6),:,:);...
        Intensity(startindex(7):endindex(7),:,:)]);
    Level = 10*log10(I); % intensity expressed in decibels
else
    endindex(1:13) = startindex(2:14)-gap;
    endindex(14) = startindex(14) + startindex(3)-startindex(2)-gap;
    if endindex(14) > len, endindex(14) = len; end
    
    % mean intensity, excluding gaps
    I = mean([Intensity(startindex(1):endindex(1),:,:);...
        Intensity(startindex(2):endindex(2),:,:);...
        Intensity(startindex(3):endindex(3),:,:);...
        Intensity(startindex(4):endindex(4),:,:);...
        Intensity(startindex(5):endindex(5),:,:);...
        Intensity(startindex(6):endindex(6),:,:);...
        Intensity(startindex(7):endindex(7),:,:);...
        Intensity(startindex(8):endindex(8),:,:);...
        Intensity(startindex(9):endindex(9),:,:);...
        Intensity(startindex(10):endindex(10),:,:);...
        Intensity(startindex(11):endindex(11),:,:);...
        Intensity(startindex(12):endindex(12),:,:);...
        Intensity(startindex(13):endindex(13),:,:);...
        Intensity(startindex(14):endindex(14),:,:)]);
    Level = 10*log10(I); % intensity expressed in decibels
end


% -------------------------------------------------------------------------
% CALCULATE MODULATION DEPTH RATIO, MDR, and MODULATION TRANSFER FUNCTION
% -------------------------------------------------------------------------

if length(startindex) == 7
    mdr = zeros(1,chans,7,2,7);
    for section = 1:7
        len = endindex(section) - startindex(section) + 1;
        
        Intensity1 = Intensity(startindex(section):endindex(section),:,:);
        Fm = Fm_all(:,:,section);
        % number of whole number cycles to use for each modulation frequency
        Fm_cycles = floor(len .* Fm./fs);
        
        % number of samples to use for each modulation frequency
        Fm_len = floor(fs.*Fm_cycles ./ Fm);
        
        % Time in seconds for each sample
        t=((1:len)-1)'./fs;
        
        % time replicated across channels
        tch = repmat(t,1,chans);
        
        
        for k = 1:7
            for j = 1:2
                % modulation depth of the received signal
                mdr(1,:,k,j,section) = 2 * ((sum(Intensity1(1:Fm_len(k,j),:,k) ...
                    .* sin(2*pi*Fm(k,j)*tch(1:Fm_len(k,j),:)))).^2 ...
                    + (sum(Intensity1(1:Fm_len(k,j),:,k) ...
                    .* cos(2*pi*Fm(k,j)*tch(1:Fm_len(k,j),:)))).^2).^0.5 ...
                    ./ sum(Intensity1(1:Fm_len(k,j),:,k));
            end
            
        end
    end
    
    Fm_nom = [0.63, 0.8, 1, 1.25, 1.6, 2, 2.5, 3.15, 4, 5, 6.25, 8, 10, 12.5];
    mdr_sort = zeros(1,chans,7,14);
    for section = 1:7
        for k = 1:7
            for j = 1:2
                Fmindex = find(Fm_nom == Fm_all(k,j,section),1,'first');
                mdr_sort(1,:,k,Fmindex) = mdr(1,:,k,j,section);
            end
        end
    end
    
    m = 0.55; % Modulation depth of STIPA signal modulators
    
    % Transform mdr to mtf using modulation depth of STI signal
    MTF = mdr_sort ./ m;
elseif length(startindex) == 14
    MTF = zeros(1,chans,7,14);
    for j = 1:14
        len = endindex(j) - startindex(j) + 1;
        
        Intensity1 = Intensity(startindex(j):endindex(j),:,:);
        Fm = Fm_all(j);
        % number of whole number cycles to use for each modulation frequency
        Fm_cycles = floor(len .* Fm./fs);
        
        % number of samples to use for each modulation frequency
        Fm_len = floor(fs.*Fm_cycles ./ Fm);
        
        % Time in seconds for each sample
        t=((1:len)-1)'./fs;
        
        % time replicated across channels and bands
        tch = repmat(t,[1,chans,7]);
        
        
        MTF(1,:,:,j) = 2 * ((sum(Intensity1(1:Fm_len,:,:) ...
            .* sin(2*pi*Fm*tch(1:Fm_len,:,:)))).^2 ...
            + (sum(Intensity1(1:Fm_len,:,:) ...
            .* cos(2*pi*Fm*tch(1:Fm_len,:,:)))).^2).^0.5 ...
            ./ sum(Intensity1(1:Fm_len,:,:));
        
        
    end
else
    % if length(startindex) == 98
end
end % eof







% -------------------------------------------------------------------------
% -------------------------------------------------------------------------
% FUNCTION TO CALCULATE STI FROM MTF
% -------------------------------------------------------------------------
% -------------------------------------------------------------------------


function [M_STI, F_STI, STIPA, MTI] = CalculateSTI(MTF)
% calculate STI values and modulation transfer indices
% from a modulation transfer function matrix

% Effecive signal to noise ratio (SNR)
SNReff=10*log10((MTF+1e-99)./(1-MTF));

% limit values to -15 <= effSNR <= 15 dB
SNReff(SNReff>15)=15;
SNReff(SNReff<-15)=-15;

% Calculate Transmission Index (TI)
% and averaged Modulation Tranasfer Index (MTI)
TI=(SNReff+15)./30;
MTI=mean(TI,1);


% STI Male
alpha=[0.085 0.127 0.230 0.233 0.309 0.224 0.173];
beta=[0.085 0.078 0.065 0.011 0.047 0.095];
MTI_alpha=alpha.*MTI;
MTI_beta=beta.*sqrt(MTI(1:length(beta)).*MTI(2:length(beta)+1));
M_STI=sum(MTI_alpha)-sum(MTI_beta);


% STI Female
alpha=[0 0.117 0.223 0.216 0.328 0.250 0.194];
beta=[0 0.099 0.066 0.062 0.025 0.076];
MTI_alpha=alpha.*MTI;
MTI_beta=beta.*sqrt(MTI(1:length(beta)).*MTI(2:length(beta)+1));
F_STI=sum(MTI_alpha)-sum(MTI_beta);


% STIPA (2011 version)
alpha=[0.085 0.127 0.230 0.233 0.309 0.224 0.173];
beta=[0.085 0.078 0.065 0.011 0.047 0.095];
MTI_STIPA = [mean([TI(5,1); TI(12,1)]), ...
    mean([TI(3,2); TI(10,2)]), ...
    mean([TI(1,3); TI(8,3)]), ...
    mean([TI(6,4); TI(13,4)]), ...
    mean([TI(4,5); TI(11,5)]), ...
    mean([TI(2,6); TI(9,6)]), ...
    mean([TI(7,7); TI(14,7)])];
MTI_alpha=alpha.*MTI_STIPA;
MTI_beta=beta.*sqrt(MTI_STIPA(1:length(beta)) ...
    .*MTI_STIPA(2:length(beta)+1));
STIPA=sum(MTI_alpha)-sum(MTI_beta);

% STIPA (2003 version)
% TO DO...

end % eof